/*#include <stdio.h>
#include <stdlib.h>

// pour htons et htonl
#include <arpa/inet.h>

// pour uint8_t, uint16_t, uint32_t, etc.
#include <stdint.h>

// pour send et recv
#include <sys/types.h>
#include <sys/socket.h>

#define PACKED __attribute__((packed))

#define CONNECT_REQ 0x1
#define CONNECT_REP 0x2

struct PACKED TON_PACKET {
    uint8_t command_id; // le type de message que tu veux envoyer
    uint8_t is_ai; // 0: GUI, 1: AI
    uint16_t size; // la taille du message
};

int memsize(uint8_t *buffer) {
    int i = 0;
    while (buffer[i]) { i++; }
    return i;
}

int encode(struct TON_PACKET msg, uint8_t *buffer) {
    buffer[0] = msg.command_id;
    buffer[1] = msg.is_ai;
    // noublie pas d'utiliser htons pour les entiers 16 bits et htonl pour les entiers 32 bits
    // comme ca tu es sur que les entiers sont bien encodes en big endian
    // et que le serveur pourra les lire correctement
    // par exemple:
    *(uint16_t *)(buffer + sizeof(uint16_t)) = htons(msg.size);
    // retourne la taille du message
    return sizeof(struct TON_PACKET);
}

void decode(uint8_t *buffer, struct TON_PACKET *msg) {
    msg->command_id = buffer[0];
    msg->is_ai = buffer[1];
    msg->size = ntohs(*(uint16_t *)(buffer + sizeof(uint16_t)));
}

int main() {
    struct TON_PACKET msg = {0};
    msg.command_id = CONNECT_REQ;
    msg.is_ai = 1;
    msg.size = sizeof(struct TON_PACKET);

    uint8_t *buffer = calloc(sizeof(struct TON_PACKET), sizeof(uint8_t));
    int size = encode(msg, buffer);
    printf("size: %d\n", size);

    struct TON_PACKET msg2 = {0};
    decode(buffer, &msg2);
    printf("command_id: %d\n", msg2.command_id);
    printf("is_ai: %d\n", msg2.is_ai);
    printf("size: %d\n", msg2.size);

    free(buffer);
    return 0;
}*/